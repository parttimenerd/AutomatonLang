package automation.lang.editor.panel;

import automation.lang.AutomationLangParser;
import automation.lang.Tree;
import automation.lang.editor.Editor;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.datatransfer.*;
import java.io.*;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JEditorPane;
import javax.swing.JFileChooser;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.Highlighter;
import javax.swing.text.Highlighter.Highlight;
import javax.swing.text.Highlighter.HighlightPainter;
import org.antlr.runtime.RecognitionException;

/**
 * Klasse, die die Textbearbeitung übernimmt und ein Textpane hier für verwaltet
 *
 * @author Johannes Bechberger
 */
public class Panel extends javax.swing.JPanel {

   private File code_file;
   private int lastfindpos = 0;
   private String lastfindtext = "";
   private ArrayList<String> actionlist = new ArrayList<String>();
   private final int MAX_ACTIONS = 30;
   private int backstepcount = 0;
   private FindFrame find_frame;
   private ReplaceFrame replace_frame;
   private int actual_lines = 0;
   private String last_eight_chars = "";
   private Tree tree;
   private final String[][] code_templates = new String[][]{
      new String[]{
         "final",
         "id \"label\": final"
      },
      new String[]{
         "init",
         "id \"label\": initial"
      },
      new String[]{
         "trans",
         "id - 9 - id2"
      }
   };
   private String highlighted_string = "";
   private HighlightPainter highlightPainter = new DefaultHighlightPainter(Color.ORANGE);
   private HighlightPainter errorHighlightPainter = new DefaultHighlightPainter(Color.RED);
   private ArrayList<int[]> mark_list = new ArrayList<int[]>(); //[y-pos, offset]
   private ArrayList<int[]> error_mark_list = new ArrayList<int[]>(); //[y-pos, offset]
   private boolean[] actual_mark_arr;
   private ArrayList<String> test_phrases = new ArrayList<String>();
   private ArrayList<Tree.Error> errors = new ArrayList<Tree.Error>();

   /**
    * Creates new form Panel
    */
   public Panel() {
      initComponents();
      while (actionlist.size() < MAX_ACTIONS) {
         actionlist.add(0, "");
      }
      codepane.setCaretPosition(0);
      find_frame = new FindFrame();
      find_frame.setLocation(0, this.getHeight() - find_frame.getHeight());
      find_frame.setSuchen_listener(new FindFrame.SuchenListener() {

         @Override
         public void actionPerformed(FindFrame.SuchenEvent evt) {
            find(evt.getSuchwort());
            //highlight(evt.getSuchwort());
         }
      });
      find_frame.setNext_listener(new FindFrame.NextListener() {

         @Override
         public void actionPerformed() {
            find_further();
         }
      });
      replace_frame = new ReplaceFrame();
      replace_frame.setLocation(0, this.getHeight() - replace_frame.getHeight());
      replace_frame.setSuchen_listener(new ReplaceFrame.SuchenListener() {

         @Override
         public void actionPerformed(ReplaceFrame.SuchenEvent evt) {
            find(evt.getSuchwort());
         }
      });
      replace_frame.setErsetzen_listener(new ReplaceFrame.ErsetzenListener() {

         @Override
         public void actionPerformed(ReplaceFrame.ErsetzenEvent evt) {
            replace(evt.getSuchwort(), evt.getErsetzungswort());
         }
      });
      codepane.setFont(new java.awt.Font("Monospaced", 0, 12));
      line_area.setFont(new java.awt.Font("Monospaced", 0, 12));
   }

   /**
    * This method is called from within the constructor to initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is always
    * regenerated by the Form Editor.
    */
   @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollpane = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        codepane = new javax.swing.JEditorPane();
        line_area = new javax.swing.JTextArea();

        setFont(new java.awt.Font("Monospaced", 0, 11)); // NOI18N
        setMaximumSize(new java.awt.Dimension(10000, 10000));
        setPreferredSize(new java.awt.Dimension(350, 250));
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        scrollpane.setPreferredSize(new java.awt.Dimension(350, 250));

        codepane.setPreferredSize(new java.awt.Dimension(10000, 10000));
        codepane.setSelectedTextColor(new java.awt.Color(0, 0, 0));
        codepane.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                codepaneMousePressed(evt);
            }
        });
        codepane.addCaretListener(new javax.swing.event.CaretListener() {
            public void caretUpdate(javax.swing.event.CaretEvent evt) {
                codepaneCaretUpdate(evt);
            }
        });
        codepane.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                codepaneKeyReleased(evt);
            }
            public void keyTyped(java.awt.event.KeyEvent evt) {
                codepaneKeyTyped(evt);
            }
        });

        line_area.setBackground(javax.swing.UIManager.getDefaults().getColor("Button.background"));
        line_area.setColumns(20);
        line_area.setEditable(false);
        line_area.setRows(4);
        line_area.setFocusable(false);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(line_area, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(codepane, javax.swing.GroupLayout.DEFAULT_SIZE, 322, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(codepane, javax.swing.GroupLayout.DEFAULT_SIZE, 250, Short.MAX_VALUE)
            .addComponent(line_area, javax.swing.GroupLayout.Alignment.TRAILING)
        );

        scrollpane.setViewportView(jPanel1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(scrollpane, javax.swing.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE)
                .addGap(20, 20, 20))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollpane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void codepaneCaretUpdate(javax.swing.event.CaretEvent evt) {//GEN-FIRST:event_codepaneCaretUpdate
       updateZeilenanzeige();
    }//GEN-LAST:event_codepaneCaretUpdate

    private void codepaneKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_codepaneKeyTyped
       if (evt.isControlDown() || evt.isAltDown()) {
          return;
       }
       //Code-Templates
       if (evt.getKeyChar() == '\t') {
          for (String[] arr : code_templates) {
             if (codeTemplateHelpMethod(arr[0], arr[1])) {
                break;
             }
          }
       }
       highlighted_string = "";
       highlight();
       actionlist.add(codepane.getText());
       if (actionlist.size() > MAX_ACTIONS) {
          actionlist.remove(0);
       }
       if (backstepcount > 0) {
          backstepcount--;
       }
       if (actionlist.size() < MAX_ACTIONS) {
          while (actionlist.size() < MAX_ACTIONS) {
             actionlist.add(0, "");
          }
       }
    }//GEN-LAST:event_codepaneKeyTyped

    private void codepaneKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_codepaneKeyReleased
       last_eight_chars += evt.getKeyChar();
       if (last_eight_chars.length() > 8) {
          last_eight_chars = last_eight_chars.substring(1);
       }
       String insert_string = "";
       if (evt.getKeyChar() == '(') {
          insert_string = ")";
       } else if (evt.getKeyChar() == '"') {
          insert_string = "\"";
       } else if (evt.getKeyChar() == '{') {
          insert_string = "}";
       } else if (evt.getKeyChar() == '\n') {
          Element root = codepane.getDocument().getDefaultRootElement();
          Element ele = root.getElement(root.getElementIndex(codepane.getCaretPosition() - 1));
          try {
             String text = codepane.getDocument().getText(ele.getStartOffset(), ele.getEndOffset() - ele.getStartOffset());
             String[] arr = text.split("[A-Za-z]");
             if (arr.length > 0) {
                if (arr[0].startsWith("\t")) {
                   insert_string = arr[0] + "\t";
                }
             }
          } catch (BadLocationException ex) {
             Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
          }
       }
       try {
          if (!"".equals(insert_string)) {
             codepane.getDocument().insertString(codepane.getCaretPosition(), insert_string, null);
             codepane.setCaretPosition(codepane.getCaretPosition() - 1);
          }
       } catch (BadLocationException ex) {
          Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
       }
    }//GEN-LAST:event_codepaneKeyReleased

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
       int y = evt.getY();
       if (evt.getX() > scrollpane.getWidth()) {
          for (int i = 0; i < mark_list.size(); i++) {
             int[] arr = mark_list.get(i);
             if (arr[0] - 2 < y && arr[0] + 2 > y) {
                codepane.setCaretPosition(arr[1]);
                actual_mark_arr[i] = true;
                return;
             }
          }
          for (int[] arr : error_mark_list) {
             if (arr[0] - 2 < y && arr[0] + 2 > y) {
                codepane.setCaretPosition(arr[1]);
                return;
             }
          }
       }
    }//GEN-LAST:event_formMouseClicked

    private void codepaneMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_codepaneMousePressed
       String text = codepane.getSelectedText();
       if (text != null) {
          int s1 = codepane.getSelectionStart();
          int s2 = codepane.getSelectionEnd();
          highlighted_string = text;
          highlight();
          codepane.select(s1, s2);
       } else {
          highlight();
       }
    }//GEN-LAST:event_codepaneMousePressed

   private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
      System.setErr(new PrintStream(System.out));
   }//GEN-LAST:event_formComponentShown
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JEditorPane codepane;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JTextArea line_area;
    private javax.swing.JScrollPane scrollpane;
    // End of variables declaration//GEN-END:variables

   @Override
   public void setBounds(int x, int y, int width, int height) {
      super.setBounds(x, y, width, height);
      find_frame.setLocation(0, this.getHeight() - find_frame.getHeight());
      replace_frame.setLocation(0, this.getHeight() - replace_frame.getHeight());
   }

   /**
    * Öffnet die Datei
    *
    * @param file Datei
    * @throws FileNotFoundException Wenn die Datei nicht existiert
    * @throws IOException
    */
   public void öffnen(File file) throws FileNotFoundException, IOException {
      if (file == null) {
         return;
      }
      BufferedReader bufreader = new BufferedReader(new FileReader(file));
      String string = bufreader.readLine();
      while (true) {
         String str = bufreader.readLine();
         if (str != null) {
            string += "\n" + str;
         } else {
            break;
         }
      }
      code_file = file;
      codepane.setText(string);
      codepane.setCaretPosition(0);
      bufreader.close();
   }

   /**
    * Speichert die den Code in dem es die den Dateinamen von dem Benutzer per
    * FileChooser erfragt, wenn die der Code dieses Panels noch nie gespeichtert
    * wurde
    *
    * @param file_chooser FileChooser
    * @throws IOException
    */
   public void speichern(JFileChooser file_chooser) throws IOException {
      if (code_file == null) {
         file_chooser.showSaveDialog(this);
         File file = file_chooser.getSelectedFile();
         if (file == null) {
            return;
         }
         code_file = file;
      }
      speichern(code_file);
   }

   /**
    * Speichert die den Code in dem es die den Dateinamen von dem Benutzer per
    * FileChooser erfragt
    *
    * @param file_chooser FileChooser
    * @throws IOException
    */
   public void speichern_unter(JFileChooser file_chooser) throws IOException {
      file_chooser.showSaveDialog(this);
      speichern(file_chooser.getSelectedFile());
   }

   /**
    * Speichert den Code dieses Panels in der übergebenen Datei
    *
    * @param file Datei
    * @throws IOException
    */
   public void speichern(File file) throws IOException {
      if (file == null) {
         return;
      }
      file.renameTo(new File(file.getAbsolutePath().split("\\.")[0] + Editor.FILE_ENDING));
      BufferedWriter bufwriter;
      if (file.exists()) {
         file.delete();
      }
      file.createNewFile();
      bufwriter = new BufferedWriter(new FileWriter(file));
      try {
         bufwriter.write(codepane.getText());
         bufwriter.flush();
      } catch (Exception ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      }
      bufwriter.close();
      code_file = file;
   }

   /**
    * Gibt den Titel dieses Panels zurück
    *
    * @return Paneltitel
    */
   public String getTitle() {
      if (code_file == null) {
         return "Unbekannt";
      } else {
         return code_file.getName();
      }
   }

   /**
    * Gibt das EditorPane zurück, auf dem der Benutzer den Code schreibt
    *
    * @return EditorPane
    */
   public JEditorPane getCodePane() {
      return codepane;
   }

   /**
    * Ruft das Findenfester auf
    */
   public void find_window() {
      find_frame.setVisible(true);
      String text = codepane.getSelectedText();
      if (text != null) {
         find_frame.setText(text);
         highlight(text);
      }
   }

   /**
    * Ruft das Ersetzenfenster auf
    */
   public void replace() {
      replace_frame.setSuchentext(codepane.getSelectedText());
      replace_frame.setVisible(true);
   }

   /**
    * Findet den aktuellen String
    *
    * @param str String
    * @return Wenn true, wurde der String gefunden, wenn false, nicht
    */
   public boolean find(String str) {
      if (str == null ? "" == null : str.equals("")) {
         return false;
      }
      lastfindtext = str;
      String text;
      try {
         Document doc = codepane.getDocument();
         text = doc.getText(0, doc.getLength());
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         return false;
      }
      highlighted_string = str;
      highlight();
      lastfindpos = text.indexOf(str);
      if (lastfindpos == -1) {
         return false;
      }
      codepane.setSelectionStart(lastfindpos);
      codepane.setSelectionEnd(lastfindpos + str.length());
      return true;
   }

   /**
    * Weitersuchen des aktuellen Suchworts
    *
    * @return Wenn true, wurde der String gefunden, wenn false, nicht
    */
   public boolean find_further() {
      if (lastfindtext == null ? "" == null : lastfindtext.equals("")) {
         return false;
      }
      String text;
      try {
         Document doc = codepane.getDocument();
         text = doc.getText(0, doc.getLength());
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         return false;
      }
      lastfindpos = text.indexOf(lastfindtext, lastfindpos + 1);
      if (lastfindpos == -1) {
         return false;
      }
      codepane.setCaretPosition(lastfindpos);
      for (int i = 0; i < mark_list.size(); i++) {
         if (mark_list.get(i)[1] == lastfindpos) {
            actual_mark_arr[i] = true;
         } else {
            actual_mark_arr[i] = false;
         }
      }
      return true;
   }

   /**
    * Findet das aktuelle Suchwort an einer Stelle vor der aktuellen Stelle
    */
   public void find_previous() {
      if (lastfindtext == null ? "" == null : lastfindtext.equals("")) {
         return;
      }
      String text;
      try {
         Document doc = codepane.getDocument();
         text = doc.getText(0, doc.getLength());
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         return;
      }
      int pos = 0;
      int prevpos = -1;
      while (pos != -1 && pos < lastfindpos) {
         pos = text.indexOf(lastfindtext, pos + 1);
         prevpos = pos;
      }
      lastfindpos = prevpos;
      if (lastfindpos == -1) {
         return;
      }
      codepane.setCaretPosition(lastfindpos);
      for (int i = 0; i < mark_list.size(); i++) {
         if (mark_list.get(i)[1] == lastfindpos) {
            actual_mark_arr[i] = true;
         } else {
            actual_mark_arr[i] = false;
         }
      }
      highlight();
      return;
   }

   /**
    * Ertetzt den String str mit dem String replacement
    *
    * @param str Zu ersetzender Text
    * @param replacement Ersetzungstext
    * @return Wenn true, wurde der String gefunden, wenn false, nicht
    */
   public boolean replace(String str, String replacement) {
      try {
         Document doc = codepane.getDocument();
         String text = doc.getText(0, doc.getLength());
         String replace = text.replace(str.subSequence(0, str.length()), replacement.substring(0, replacement.length()));
         if (replace.equals(text)) {
            return false;
         }
         codepane.setText("");
         codepane.getDocument().insertString(0, replace, null);
         highlight(replacement);
         return true;
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         return false;
      }
   }

   private void ausschneiden(boolean bool) {
      if (codepane.getSelectedText() == null) {
         return;
      }
      if (bool) {
         kopieren();
      }
      try {
         codepane.getDocument().remove(codepane.getSelectionStart(), codepane.getSelectionEnd());
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      }
   }

   /**
    * Schneidet den markierten Text aus
    */
   public void ausschneiden() {
      ausschneiden(true);
   }

   /**
    * Entfernt den markierten Text
    */
   public void entfernen() {
      ausschneiden(false);
   }

   /**
    * Macht die aktuelle Eingabe rückgängig
    */
   public void undo() {
      if (backstepcount > MAX_ACTIONS || backstepcount < 0) {
         //backstepcount = 0;
         return;
      }
      try {
         codepane.setText(actionlist.get(MAX_ACTIONS - backstepcount - 1));
      } catch (Exception ex) {
      }
      backstepcount++;
   }

   /**
    * Wiederholt die letzte Eingabe, die rückgängig gemacht wurde
    */
   public void redo() {
      if (backstepcount > 0) {
         backstepcount--;
         try {
            codepane.setText(actionlist.get(MAX_ACTIONS - backstepcount - 1));
         } catch (Exception ex) {
         }
      }
   }

   /**
    * Markiert den ganzen Text
    */
   public void alles_markieren() {
      codepane.setSelectionStart(0);
      codepane.setSelectionEnd(codepane.getDocument().getLength());
   }

   /**
    * @return Gibt an, ob das Rückgängigmachen möglich ist
    */
   public boolean isUndoAvaliable() {
      if (backstepcount - 1 < MAX_ACTIONS) {
         return true;
      }
      return false;
   }

   /**
    * @return Gibt an, ob das Wiederholen möglich ist
    */
   public boolean isRedoAvaliable() {
      if (backstepcount > 0) {
         return true;
      }
      return false;
   }

   /**
    * @return Gibt an, ob das Kopieren möglich ist
    */
   public boolean isCopyAvaliable() {
      if (codepane.getSelectedText() != null) {
         return true;
      }
      return false;
   }

   /**
    * @return Gibt an, ob das Ausschneiden möglich ist
    */
   public boolean isCutAvaliable() {
      return isCopyAvaliable();
   }

   /**
    * @return Gibt an, ob das Weitersuchen möglich ist
    */
   public boolean isFindFurtherAvaliable() {
      if (lastfindtext == null || "".equals(lastfindtext)) {
         return false;
      }
      return true;
   }

   /**
    * Fügt den Text aus der Zwischenablage an der Position des TextCursors (d.h
    * Caret) ein
    */
   public void einfügen() {
      try {
         Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemSelection();
         Transferable contents = clipboard.getContents(this);
         if (contents == null) {
            return;
         }
         String text = (String) contents.getTransferData(DataFlavor.stringFlavor);
         if (text != null) {
            codepane.getDocument().insertString(codepane.getCaretPosition(), text, null);
         }
      } catch (UnsupportedFlavorException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      } catch (IOException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      }
   }

   /**
    * Kopiert den makierten Text
    */
   public void kopieren() {
      String text = codepane.getSelectedText();
      if (text != null) {
         StringSelection selection = new StringSelection(text);
         Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, null);
      }
   }

   /**
    * Aktualisiert die Zeilenanzeige
    */
   private void updateZeilenanzeige() {
      int lines = codepane.getDocument().getDefaultRootElement().getElementCount();
      if (actual_lines == lines + 1) {
         return;
      }
      if (actual_lines < lines + 1) {
         while (actual_lines < lines) {
            line_area.append((actual_lines > 8 ? (actual_lines > 98 ? "" : " ") : "  ") + (actual_lines + 1) + "\n");
            actual_lines++;
         }
      } else {
         actual_lines = 0;
         line_area.setText("");
         updateZeilenanzeige();
      }
      highlight();
   }

   /**
    * Ersetzt der Template Shortcut mit dem Templatetext, wenn möglich
    *
    * @param shortcut Template Shortcut
    * @param template Templatetext
    * @return Wenn true, ersetzen möglich (d.h. das aktuell eingetippte Shortcut
    * shortcut entspricht), wenn false nicht
    */
   private boolean codeTemplateHelpMethod(String shortcut, String template) {
      if (last_eight_chars.indexOf(shortcut, 8 - shortcut.length()) == -1) {
         return false;
      }
      try {
         Document doc = codepane.getDocument();
         String text = doc.getText(0, doc.getLength());
         int pos = codepane.getCaretPosition();
         codepane.setText("");
         codepane.getDocument().insertString(0, text.substring(0, pos - shortcut.length() - 1)
                 + template + text.substring(pos), null);
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         return false;
      }
      return true;
   }

   /**
    * Rückt den markierten Text ein
    */
   public void einrücken() {
      Element root = codepane.getDocument().getDefaultRootElement();
      int fromline = root.getElementIndex(codepane.getSelectionStart());
      int toline = root.getElementIndex(codepane.getSelectionEnd());
      for (int i = fromline; i <= toline; i++) {
         Document doc = root.getElement(i).getDocument();
         try {
            doc.insertString(root.getElement(i).getStartOffset(), "\t", null);
         } catch (BadLocationException ex) {
            Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         }
      }
   }

   /**
    * Rückt den markierten Text aus
    */
   public void ausrücken() {
      Element root = codepane.getDocument().getDefaultRootElement();
      int fromline = root.getElementIndex(codepane.getSelectionStart());
      int toline = root.getElementIndex(codepane.getSelectionEnd());
      for (int i = fromline; i <= toline; i++) {
         Document doc = root.getElement(i).getDocument();
         Element element = root.getElement(i);
         try {
            if (doc.getText(element.getStartOffset(), element.getEndOffset() - element.getStartOffset()).startsWith("\t")) {
               doc.remove(element.getStartOffset(), 1);
            }
         } catch (BadLocationException ex) {
            Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         }
      }
   }

   /**
    * Hervorhebt den Text des highlighted_string im EditorPane
    */
   public void highlight() {
      Highlighter highlighter = codepane.getHighlighter();
      mark_list.clear();
      error_mark_list.clear();
      for (Highlight highlight : highlighter.getHighlights()) {
         if (highlight.getPainter() == errorHighlightPainter || highlight.getPainter() == highlightPainter) {
            highlighter.removeHighlight(highlight);
         }
      }
      double faktor = this.getHeight() * 1.0 / codepane.getHeight();
      int font_height = codepane.getFontMetrics(codepane.getFont()).getHeight() / 2;

      for (Tree.Error error : errors) {
         try {
            int[] arr = getPosForLineAndOffset(error.line, error.offset);
            highlighter.addHighlight(arr[0], arr[1], errorHighlightPainter);
            error_mark_list.add(new int[]{
                       (int) ((error.line - font_height) * faktor),
                       arr[0]
                    });
         } catch (BadLocationException ex) {
            //Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         }
      }
      if (highlighted_string == "") {
         return;
      }
      Document doc = codepane.getDocument();
      String text;
      try {
         text = doc.getText(0, doc.getLength());
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         return;
      }
      int pos = 0;
      pos = text.indexOf(highlighted_string, pos);
      while (pos >= 0) {
         try {
            highlighter.addHighlight(pos, pos + highlighted_string.length(), highlightPainter);
            pos += highlighted_string.length();
            mark_list.add(new int[]{
                       (int) ((codepane.modelToView(pos).getY() - font_height) * faktor),
                       pos
                    });
         } catch (BadLocationException ex) {
            Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
         }
         pos = text.indexOf(highlighted_string, pos);
      }
      actual_mark_arr = new boolean[mark_list.size()];
      for (int i = 0; i < mark_list.size(); i++) {
         actual_mark_arr[i] = false;
      }
      this.repaint();
   }

   public int getLineNumber(int pos) {
      int posLine;
      int y = 0;
      Rectangle caretCoords = null;
      try {
         caretCoords = codepane.modelToView(pos);
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      }
      y = (int) caretCoords.getY();
      int lineHeight = codepane.getFontMetrics(codepane.getFont()).getHeight();
      posLine = (y / lineHeight) + 1;
      return posLine;
   }
   
   public int[] getPosForLineAndOffset(int line, int offset){
      Element ele = codepane.getDocument().getDefaultRootElement().getElement(line - 1);
      return new int[]{ele.getStartOffset() + offset, ele.getEndOffset()};
   }

   /**
    * Hevorhebt den Text des strings im EditorPane
    *
    * @param string Text der hervorgehoben werden
    */
   public void highlight(String string) {
      if (string != null) {
         highlighted_string = string;
         highlight();
      }
   }

   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);
      g.setColor(Color.GRAY);
      int x = scrollpane.getWidth();
      int width = this.getWidth() - x;
      int x2 = x + (width / 2);
      for (int i = 0; i < mark_list.size(); i++) {
         int[] arr = mark_list.get(i);
         g.fillRect(x, arr[0] - 2, width, 3);
         if (actual_mark_arr[i]) {
            g.setColor(Color.ORANGE);
            g.fillRect(x2, arr[0] - 2, 5, 5);
            g.setColor(Color.GRAY);
         }
      }
      g.setColor(Color.RED);
      for (int[] arr : error_mark_list) {
         g.fillRect(x, arr[0] - 2, width, 3);
      }
   }

   /**
    * Setzt den Textcursor (d.h. Caret) an die Position offset
    *
    * @param offset Position
    */
   public void setCaret(int offset) {
      codepane.setCaretPosition(offset);
   }

   /**
    * Gibt die TodoListItem Liste zurück
    *
    * @return TodoListItem Liste
    */
   public ArrayList<TodoListItem> getTodoList() {
      ArrayList<TodoListItem> list = new ArrayList<TodoListItem>();
      String text = codepane.getText();
      int pos = text.indexOf("TODO ");
      while (pos != -1) {
         String str = text.substring(pos + 5);
         str = str.split("\\n")[0];
         if (!"".equals(str)) {
            list.add(new TodoListItem(str.trim(), pos, this));
         }
         pos = text.indexOf("TODO", pos + 1);
      }
      return list;
   }

   public void ausführen(JFileChooser file_chooser) {
      try {
         System.setErr(new PrintStream(System.out));
         errors.clear();
         speichern(file_chooser);
         String file = code_file.getAbsolutePath();
         Document doc = this.getCodePane().getDocument();
         long time = System.currentTimeMillis();
         tree = AutomationLangParser.saveCodeInFileAndParseToTree(doc.getText(0, doc.getLength()), file);
         System.out.println("Interpret code (" + (System.currentTimeMillis() - time) + "ms)...");
         File f = new File(file + ".jff");
         if (f.exists()) {
            f.delete();
         }
         f.createNewFile();
         FileWriter writer = new FileWriter(f);
         writer.write(tree.serialize());
         writer.close();
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      } catch (IOException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      } catch (RecognitionException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      }
      highlight();
   }

   public void simpleExecute() {
      try {
         System.setErr(new PrintStream(System.out));
         errors.clear();
         File file = File.createTempFile("automationlang", ".al");
         Document doc = this.getCodePane().getDocument();
         long time = System.currentTimeMillis();
         tree = AutomationLangParser.saveCodeInFileAndParseToTree(doc.getText(0, doc.getLength()), file.getAbsolutePath());
         System.out.println("Interpret code (" + (System.currentTimeMillis() - time) + "ms)...");
         file.delete();
      } catch (IOException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      } catch (RecognitionException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      } catch (BadLocationException ex) {
         Logger.getLogger(Panel.class.getName()).log(Level.SEVERE, null, ex);
      }
      highlight();
   }

   public Tree getTree() {
      return tree;
   }

   public String[] getTestPhrases() {
      String[] arr = (String[]) test_phrases.toArray();
      return arr;
   }

   public void addTestPhrase(String test_phrase) {
      if (test_phrases.isEmpty() || test_phrases.get(0) != test_phrase) {
         test_phrases.add(0, test_phrase);
      }
   }

   public ArrayList<Tree.Error> getErrors() {
      return errors;
   }

   public File getCode_file() {
      return code_file;
   }

   /**
    * Eintrag der TodoListe
    */
   public class TodoListItem {

      private int offset;
      private String text;
      private int line;
      private Panel panel;

      /**
       * Konstruktor dieser Klasse
       *
       * @param text TODO Text
       * @param offset Position im Text
       * @param panel diesen TODO Text enthaltendes Panel
       */
      public TodoListItem(String text, int offset, Panel panel) {
         this.text = text;
         this.offset = offset;
         this.line = codepane.getDocument().getDefaultRootElement().getElementIndex(offset) + 1;
         this.panel = panel;
      }

      /**
       * @return the offset
       */
      public int getOffset() {
         return offset;
      }

      /**
       * @return the text
       */
      public String getText() {
         return text;
      }

      /**
       * @return the line
       */
      public int getLine() {
         return line;
      }

      /**
       * @return the panel
       */
      public Panel getPanel() {
         return panel;
      }

      @Override
      public String toString() {
         return text;
      }
   }

   public class PrintStream extends java.io.PrintStream {

      public PrintStream(OutputStream out) {
         super(out);
      }

      @Override
      public void println(String x) {
         if (x.split(" line ").length > 1) {
            errors.add(parseString(x));
         } else {
            super.println(x);
         }
      }

      public Tree.Error parseString(String str) {
         String[] arr = str.split(" line ", 2)[1].split(":", 2);
         String[] arr2 = arr[1].split(" ", 2);
         return new Tree.Error(Integer.parseInt(arr[0]),
                 Integer.parseInt(arr2[0]), arr2[1]);
      }
   }
}
